# 数据结构

## 第1章 绪论

#### 1.数据结构相关概念

**数据**：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整形、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。
数据，也就是符号，必须具备两个前提：
a.可以输入到计算机中
b.能被计算机程序处理

**数据元素**：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。

**数据项**：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

**数据对象**：是性质相同的数据元素的集合，是数据的子集。
什么叫性质相同呢？是指数据元素具有相同数量和类型的数据项，比如人 这个例子，都有姓名、生日、性别等相同的数据项。
既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同性质，在不产生混淆的情况下，<u>我们将数据对象简称为数据。</u>

**数据结构**：是相互之间存在一种或者多种特定关系的数据元素的集合。
![image-20210303153041864](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210303153041864.png)

#### 2.分类

![image-20210303153204389](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210303153204389.png)

#### 3.抽象数据结构（ADT，abstract data type）

```
ADT=(D,S,P)
```

其中D是数据对象，S是D上的关系集，P是加在D上的一组操作。在定义抽象数据类型时，我们使用以下格式： 

```
ADT抽象数据类型名{
	数据对象：<数据对象的定义>
	数据关系：<数据关系的定义>
	基本操作：<基本操作的定义>
}
```

![image-20210303153601832](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210303153601832.png)

## 第2章 算法

#### 1.一些定义

算法的定义：算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。
算法的特性：有穷性、确定性、可行性、输入、输出。
算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求。
算法特性与算法设计容易混，需要对比记忆。
算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。

#### 2.常见时间复杂度排序

![image-20210303153954264](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210303153954264.png)

## 第3章 线性表

#### 1.定义

零个或多个数据元素的有限序列。

![image-20210305122542356](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210305122542356.png)

#### 2.抽象数据结构

```
ADT 线性表(List)
Data
	线性表的数据对象集合为{a1,a2,-,an},每个元素的类型均为 DataType。其中,除第
一个元素a1外,每一个元素有且只有一个直接前驱元素,除了最后一个元素an外,每一个元
素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
	Initlist(*L):初始化操作,建立一个空的线性表L。
	ListEmpty(L):若线性表为空,返回true,否则返回fa1se。
	Clearlist(*L):将线性表清空。
	GetElem(L,i,*e):将线性表L中的第1个位置元素值返回给e。
	LocateElem(L,e):在线性表L中查找与给定值e相等的元素,如果查找成功,返回
					该元素在表中序号表示成功;否则,返回0表示失败
	ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e。
	ListDelete(*L,i,*e):删除线性表L中第i个位置元素,并用e返回其值。
	ListLength(L):返回线性表L的元素个数
endADT
```

#### 3.顺序存储结构

````
#define MAXSIZE 20    /*存储空间初始化分配量*/
typedef int ElemType; /*数据类型*/
typedef struct{
	ElemType data[MAXSIE];	/*数组存储*/
	int length;		/*线性表当前长度*/
}SqList;
````

#### 4.链式存储结构

##### 4.1头指针和头结点的异同

![image-20210305121515579](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210305121515579.png)

##### 4.2单链表存储结构

```
typedef struct Node
{
	ElemType data;/*数据域*/
	struct Node* next;/*指针域*/
}Node;
typedef struct Node *LinkList;/*定义LinkList*/
```

##### 4.3静态链表

```
#define MAXSIZE 1000   
typedef int ElemType; /*数据类型*/
typedef struct{
	ElemType data;	/*数据域*/
	int cur;		/*游标，为0时表示无指向*/
}Component,StaticLinkList(MAXSIZE);
```

![image-20210305122228118](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210305122228118.png)

##### 4.4循环链表

头尾相连

##### 4.5双向链表

```
typedef struct Node
{
	ElemType data;/*数据域*/
	struct Node* prior;/*直接前驱指针*/
	struct Node* next;/*直接后继指针*/
}DulNode,*DuLinkList;
```

## 第4章 栈与队列

#### 1.栈的定义

栈是限定仅在表尾进行插入和删除操作的线性表。

LIFO（last in first out）

#### 2.栈的抽象数据类型

```
ADT 栈(stack)
Data
	同线性表。元素属性相同，相邻元素具有前驱和后继关系。
Operation
	InitStack(*S):初始化操作,建立一个空栈。
	StackEmpty(S):若栈为空,返回true,否则返回fa1se。
	ClearStack(*L):将栈清空。
	DestroyStack(*S):若栈存在，销毁栈。
	GetTop(S,*e):若栈存在且非空，将栈顶元素值返回给e。
	Push(*S,e):若栈存在，插入e成为栈顶元素。
	Pop(*S,e):删除栈顶元素,并用e返回其值。
	StackLength(L):返回栈的元素个数
endADT
```

#### 3.栈的顺序存储结构

```
typedef int ElemType;
typedef struct 
{
	ElemType data[MAXSIZE];
	int top;	/*用于栈顶指针，始终指向栈顶元素*/
}SqStack
```

#### 4.两栈共享空间

![image-20210308185834180](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210308185834180.png)

````
typedef int ElemType;
typedef struct 
{
	ElemType data[MAXSIZE];
	int top1;	/*栈1栈顶指针*/
	int top2;	/*栈2栈顶指针*/
}SqDoubleStack
````

#### 5.栈的链式存储结构

```
tips:
	1.链栈不需要头结点，top直接指向第一个节点；
	2.进栈采用头插法，在头部操作。
	
typedef struct StackNode
{
	ElemType data;
	struct StackNode *next;
}StackNode,*LinkStackPtr;

typedef struct LinkStack
{
	LinkStackPtr top;
	int count;
}LinkStack;
```

#### 6.栈的应用——四则运算表达式求值

分为两步

***1.将中缀表达式转换为后缀表达式（栈用来进出运算符号）。***

​	规则：从左到右遍历中缀表达式式的每一个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，咋判断与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到输出后缀表达式为止。

***2.将后缀表达式进行运算（栈用来进出运算数字）。***

​    规则：从左到右遍历表达式，遇到数字就进栈，遇到符号，，就将处于栈顶的两个数字出站，进行运算，      运算结果进栈，一直到最终获得结果。

#### 7.队列的定义

队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

#### 8.队列的抽象数据类型

```
ADT 队列(Queue)
Data
	同线性表。元素属性相同，相邻元素具有前驱和后继关系。
Operation
	InitQueue(*Q):初始化操作,建立一个空队列。
	QueueEmpty(Q):若队列为空,返回true,否则返回fa1se。
	ClearQueue(*Q):将队列清空。
	DestroyQueue(*Q):若队列存在，销毁它。
	GetHead(Q,*e):若队列存在且非空，将队头元素值返回给e。
	EnQueue(*Q,e):若队列存在，插入e成为队尾元素。
	DeQueue(*Q,e):删除队头元素,并用e返回其值。
	QueueLength(Q):返回队列的元素个数
endADT
```

#### 9.队列的顺序存储结构——循环队列

​	

```
tips：
	1.计算队列长度  (rear-front+MAXSIZE)%MAXSIZE
	2.何时为空？front==rear
	3.何时满？(rear+1)%MAXSIZE==front

typedef struct
{
	ElemType data[MAXSIZE];
	int front;		/*头指针，初始时front=rear*/
	int rear;		/*尾指针，若队列不空，指向队尾元素的下一个位置*/
}SqQueue
```

#### 10.队列的链式存储结构

```
tips：
	1.为了操作方便，将队头指针指向头结点，即无数据那个
	2.何时为空？front==rear
	
typedef struct QNode
{
	ElemType data;
	struct QNode *next;
}QNode,*QueuePtr;

typedef struct 
{
	QueuePtr front,rear;
}LinkQueue;
```

## 第5章 串

#### 1.串的定义

串(string)是由零个或多个字符组成的有限序列，又名叫字符串。

#### 2.串的抽象数据类型

```
tips:
	1.通常字符串第一位存储字符串的长度。
	
	
ADT 串(string)
Data
	串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
	StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T。
	StrCopy(T,S):串S存在，由串S复制得串T。
	ClearString(S):串S存在，将串清空。
	StringEmpty(S):若串S为空，返回true，否则返回false。
	StrLength(S):返回串S的元素个数，即串的长度。
	StrCompare(S,T):若S>T,返回值>0,若S=T，返回0，若S<T,返回值<0。
	Concat(T,S1,S2):用T返回由S1和S2连接而成的新串。
	SubString(Sub,S,pos,len):串S存在，1<=pos<=StrLength(s),且0<=len<=StrLength(s)-pos+1,用						Sub返回串S的第pos个字符起长度为len的子串。
	Index(S,T,pos):串S和T存在，T是非空串，1<=pos<=StrLength(S)。若主串S中存在和串T值相同的子					串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。
	Replace(S,T,V):串S、T和V存在，T是非空串。用V替换转船S中出现的所有与T相等的不重叠的子串。
	StrInsert(S,pos,T):串S和T存在，1<=pos<=StrLength(s)+1。在串S的第pos个字符之前插入串T。
	StrDelete(S,pos,len):串S存在，1<=pos<=StrLength(S)-len+1。从串S中删除第pos个字符起长度为						len的子串。
endADT
```

#### 3.朴素的模式匹配算法BF

	    BF算法即暴风算法，是普通的模式匹配算法。BF算法的思想：将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。
```
int Index(String S,String T,int pos){
    int i=pos;/*i用于主串S当前位置下标*/
    int j=1;/*j用于子串T当前位置下标*/
    while(i<=S[0]&&j<=T[0]){/*这里字符串的第一位为字符串的长度*/
        if(S[i]==T[j]){
            i++;
            j++;
        }else{
            i=i-j+2;/*i退回到上次匹配首位的下一位*/
        }
    }
    if(j>T[0])
        return i-T[0];
    else
        return 0;
    
}
```

#### 4.KMP算法

```
KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。
```

​	简单理解：https://www.bilibili.com/video/BV1jb411V78H?from=search&seid=12237842459230427818

​	java版本代码：https://www.cnblogs.com/dusf/p/kmp.html

```
/*获得next数组*/
void get_next(String t,int* next){
    int i=1,j=0;
    next[i]=0;
    while(i<t[0]){
        if(j==0||t[i]==t[j]){/*t[i]表示后缀的单个字符   t[j]表示前缀的单个字符*/
            i++;
            j++;
            next[i]=j;
        }else{
            j=next[j];/*若字符不相同，j回溯*/
        }
    }
       
}
/*返回子串T在主串S中第pos个字符之后的位置，若不存在，返回0*/
int Index_KMP(String S,String T,int pos){
    int i=pos;/*i用于主串S当前位置下标*/
    int j=1;/*j用于子串T当前位置下标*/
    int next[255];
    get_next(T,next);
    while(i<=S[0]&&j<=T[0]){
        if(j==0||S[i]==T[j]){
            i++;
            j++;
        }else{
            j=next[j];
        }
    }
    if(j>T[0])
        return i-T[0];
    else
        return 0;
    
}
```

```
改进get_next()
/*获得next数组*/
void get_next(String t,int* next){
    int i=1,j=0;
    next[i]=0;
    while(i<t[0]){
        if(j==0||t[i]==t[j]){/*t[i]表示后缀的单个字符   t[j]表示前缀的单个字符*/
            i++;
            j++;
            if(T[i]!=T[j])
            	next[i]=j;
            else
            	next[i]=next[j];
        }else{
            j=next[j];/*若字符不相同，j回溯*/
        }
    }
       
}
```

## 第6章 树

#### 1.定义

树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中:(1)有且仅有一个特定的称为根(Root)的结点;(2)当n>1时,其余结点可分为m(m>0)个互不相交的有限集Tl、T2、……、Tm,其中每一个集合本身又是一棵树,并且称为根的子树( Subtree)。

#### 2.树的抽象数据结构

![image-20210312205421906](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312205421906.png)

#### 3.树的存储结构

##### 3.1双亲表示法

![image-20210312205934649](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312205934649.png)

```
typedef struct PTNode{
 	TElemType data;/*结点数据*/
 	int parent;/*双亲位置*/
}PTNode;
typedef struct{
	PTNode nodes[MAX_TREE_SIZE];/*结点数组*/
	int r,n;/*根的位置和结点总数*/
}PTree;
```

##### 3.2孩子表示法

![image-20210312210031382](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312210031382.png)

```
typedef struct CTNode{
 	int child;/*孩子位置*/
 	struct CTNode* next;
}*ChildPtr;

typedef struct{/*表头结构*/
 	TElemType data;/*结点数据*/
 	ChildPtr firstchild;
}CTBox;
typedef struct{/*树结构*/
	CTBox nodes[MAX_TREE_SIZE];/*结点数组*/
	int r,n;/*根的位置和结点总数*/
}PTree;
```

##### 3.3孩子兄弟表示法

```
typedef struct CSNode{
 	TElemType data;/*结点数据*/
 	struct CSNode* firstchild,*rightsib;
}CSNode,*CSTree;
```

#### 4.二叉树定义

二叉树( Binary Tree)是n(n≥0)个结点的有限集合,该集合或者为空集(称为空二叉树)或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

##### 4.1特殊二叉树

###### 4.1.1斜树

所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜
树。斜树有很明显的特点,就是每一层都只有一个结点,结点的个数与二叉树的深度相同。

###### 4.1.2满二叉树

在一棵二叉树中,如果所有分支结点都存在左子树和右子树,并且所有叶子都在同一层上,这样的二叉树称为满二叉树。

![image-20210312211134176](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312211134176.png)

###### 4.1.3完全二叉树

对一棵具有n个结点的二叉树按层序编号,如果编号为i(1≤i≤n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同,则这棵二叉树称为完全二叉树,如图所示。

![image-20210312211123912](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312211123912.png)

#### 5.二叉树的性质

性质1:在二叉树的第i层上至多有2^(n-1)个结点(≥1)。

性质2:深度为k的二叉树至多有2^k - 1个结点(k≥1)。

性质3:对任何一棵二叉树T,如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1。

性质4:具有n个结点的完全二叉树的深度为![image-20210312211530399](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312211530399.png)(向下取整)。

性质5:如果对一棵有n个结点的完全二叉树(其深度为![image-20210312211530399](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312211530399.png))的结点按层
序编号(从第1层到第![image-20210312211530399](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312211530399.png)层,每层从左到右),对任一结点i(1≤i≤n)
	1.如果i=1,则结点i是二叉树的根,无双亲;如果i>1,则其双亲是结点i/2向下取整。
	2.如果2i>n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i
	3.如果2i+1>n,则结点i无右孩子;否则其右孩子是结点2i+1。

#### 6.二叉树的顺序存储

​																*仅仅适用于完全二叉树*

![image-20210312211836552](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312211836552.png)

#### 7.二叉链表

```
typedef struct BiNode{
	TElemType data;
	struct BiNode *lchild,*rchild;
}BiNode,*BiTree;
```

#### 8.遍历二叉树

​		**1.前序遍历**

![image-20210312212208516](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312212208516.png)

​		如图，遍历顺序为：ABDGHCEIF

```
void PreOrderTraverse(BiTree T){
	if(T==NULL)
		return;
	print("%c",T->data);
	PreOrderTraverse(T->lchild);
	PreOrderTraverse(T->rchild);
}
```

​		**2.中序遍历**

![image-20210312212449910](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312212449910.png)

​        	如图，遍历顺序为：GDHBAEICF

​			**3.后序遍历**

![image-20210312212607264](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312212607264.png)

​			如图，遍历顺序为：GHDBIEFCA

​			**4.层次遍历**

​		![image-20210312212712904](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312212712904.png)

​				如图，遍历顺序为：ABCDEFGHI

#### 9.建立二叉树

```
void CreateBiTree(BiTree *T){
	TElemType ch;
	scanf("%c",&ch);
	if(ch=="#")
		*T=NULL;
	else{
		*T=(BiTree)malloc(sizeof(BiTNode));
		if(!*T)
			exit(OVERFLOW);
		*T->data=ch;
		CreateBiTree(&(*T)->lchild);
		CreateBiTree(&(*T)->rchild);
	}
}
```

#### 10.线索二叉树

我们把指向前驱和后继的指针称为线索,加上线索的二叉链表称为线索链表,相应的二叉树就称为线索二叉树(Threaded Binary Tree）

![image-20210312213244307](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312213244307.png)

```
typedef enum {Link,Thread} PointerTag;

typedef struct BiThrNode{
	TElemType data;
	struct BiThrNode*lchild,*rchild;
	PointerTag LTag;
	PointerTag RTag;
}BiThrNode,*BiThrTree;
```

```
中序遍历线索化递归
BiThrTree pre; /*全局变量，始终指向刚刚访问过得结点*/
void InThreading(BiThrTee p){
	if(p){
		InThreading(p->lchild);
		
		if(!p->lchild){
			p->LTag=Thread;		/*前驱线索*/
			p->lchild=pre;		/*左孩子指针指向前驱*/
		}
		if(!pre->rchild){
			pre->RTag=Thread;  
			pre->rchild=p;
		}
		pre=p;/*保持pre更新*/
		
		InThreading(p->rchild);
	}
}
```

```	
中序遍历线索树--带有头结点 时间复杂度为O(n)
status InOrderTraverse_Thr(BiThrTree T){
	BiThrTree p;
	p=T->lchild; /*p指向根节点*/
	while(p!=T){
		while(p->LTag==Link)/*当LTag==0时循环到中序序列第一个结点*/
			p=p->lchild;
		printf("%c",p->data);
		while(p->RTag==Thread&&p-rchild!=T){
			p=p->rchild;
			printf("%c",p->data);
		}
		p=p->rchild;/*p进行至其右子树根*/
	}
	return OK;
}
```

![image-20210312214424636](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210312214424636.png)

#### 11.树、森林和二叉树的转化

1.树->二叉树

![image-20210314191541825](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210314191541825.png)

2.森林->二叉树

![image-20210314191639850](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210314191639850.png)

3.二叉树->树

![image-20210314191708726](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210314191708726.png)

4.二叉树->森林

![image-20210314191730814](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210314191730814.png)

#### 12.树与森林遍历

![image-20210314191827142](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210314191827142.png)

#### 13.哈夫曼树

```
//哈夫曼树结点结构
typedef struct {
    int weight;//结点权重
    int parent, left, right;//父结点、左孩子、右孩子在数组中的位置下标
}HTNode, *HuffmanTree;
//动态二维数组，存储哈夫曼编码
typedef char ** HuffmanCode;
```

